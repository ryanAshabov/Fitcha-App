/*
  # Integrated Matchmaking & Booking Engine

  This migration creates the core tables and functions for Fitcha's revolutionary
  matchmaking and booking system that transforms the platform into a complete
  sports marketplace.

  ## New Tables
  1. **game_sessions** - The heart of the matchmaking engine
  2. **session_chat_messages** - Real-time chat for each game session
  3. **enhanced_bookings** - Updated bookings table with session tracking

  ## Key Features
  - End-to-end matchmaking flow
  - Real-time session-based chat
  - Smart payment splitting
  - Automated court suggestions
  - Session status tracking
*/

-- Create game_sessions table (The heart of the matchmaking engine)
CREATE TABLE IF NOT EXISTS game_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  status text NOT NULL DEFAULT 'pending_acceptance' CHECK (status IN (
    'pending_acceptance',
    'court_selection', 
    'pending_payment',
    'confirmed',
    'completed',
    'cancelled'
  )),
  initiator_id uuid NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
  invitee_id uuid NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
  sport text NOT NULL,
  proposed_datetime timestamptz NOT NULL,
  selected_court_id uuid REFERENCES courts(id) ON DELETE SET NULL,
  total_cost numeric,
  payment_option text CHECK (payment_option IN ('initiator_pays_all', 'split_50_50', 'custom_split')),
  initiator_payment_status text DEFAULT 'pending' CHECK (initiator_payment_status IN ('pending', 'paid', 'not_required')),
  invitee_payment_status text DEFAULT 'pending' CHECK (invitee_payment_status IN ('pending', 'paid', 'not_required')),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  -- Prevent self-invitations
  CHECK (initiator_id != invitee_id)
);

-- Create session_chat_messages table
CREATE TABLE IF NOT EXISTS session_chat_messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id uuid NOT NULL REFERENCES game_sessions(id) ON DELETE CASCADE,
  sender_id uuid NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
  message text NOT NULL,
  message_type text DEFAULT 'text' CHECK (message_type IN ('text', 'court_suggestion', 'payment_request', 'system')),
  metadata jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now()
);

-- Update bookings table to include session tracking
DO $$
BEGIN
  -- Add session_id column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'bookings' AND column_name = 'session_id'
  ) THEN
    ALTER TABLE bookings ADD COLUMN session_id uuid REFERENCES game_sessions(id) ON DELETE SET NULL;
  END IF;
  
  -- Add booked_by_user_id column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'bookings' AND column_name = 'booked_by_user_id'
  ) THEN
    ALTER TABLE bookings ADD COLUMN booked_by_user_id uuid REFERENCES profiles(user_id) ON DELETE SET NULL;
  END IF;
  
  -- Add final_cost column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'bookings' AND column_name = 'final_cost'
  ) THEN
    ALTER TABLE bookings ADD COLUMN final_cost numeric;
  END IF;
END $$;

-- Enable RLS
ALTER TABLE game_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_chat_messages ENABLE ROW LEVEL SECURITY;

-- RLS Policies for game_sessions
CREATE POLICY "Users can view sessions they are involved in"
  ON game_sessions
  FOR SELECT
  TO authenticated
  USING (initiator_id = auth.uid() OR invitee_id = auth.uid());

CREATE POLICY "Users can create sessions as initiator"
  ON game_sessions
  FOR INSERT
  TO authenticated
  WITH CHECK (initiator_id = auth.uid());

CREATE POLICY "Participants can update their sessions"
  ON game_sessions
  FOR UPDATE
  TO authenticated
  USING (initiator_id = auth.uid() OR invitee_id = auth.uid());

-- RLS Policies for session_chat_messages
CREATE POLICY "Users can view messages in their sessions"
  ON session_chat_messages
  FOR SELECT
  TO authenticated
  USING (
    session_id IN (
      SELECT id FROM game_sessions 
      WHERE initiator_id = auth.uid() OR invitee_id = auth.uid()
    )
  );

CREATE POLICY "Users can send messages in their sessions"
  ON session_chat_messages
  FOR INSERT
  TO authenticated
  WITH CHECK (
    sender_id = auth.uid() AND
    session_id IN (
      SELECT id FROM game_sessions 
      WHERE initiator_id = auth.uid() OR invitee_id = auth.uid()
    )
  );

-- Function to suggest courts based on user locations and preferences
CREATE OR REPLACE FUNCTION suggest_courts_for_session(
  p_session_id uuid,
  p_limit integer DEFAULT 10
)
RETURNS TABLE (
  court_id uuid,
  court_name text,
  court_address text,
  hourly_price numeric,
  distance_km numeric,
  availability_score numeric
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_session RECORD;
  v_initiator_lat numeric;
  v_initiator_lng numeric;
  v_invitee_lat numeric;
  v_invitee_lng numeric;
  v_midpoint_lat numeric;
  v_midpoint_lng numeric;
BEGIN
  -- Get session details
  SELECT gs.*, gs.sport, gs.proposed_datetime
  INTO v_session
  FROM game_sessions gs
  WHERE gs.id = p_session_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Session not found';
  END IF;
  
  -- Get user locations
  SELECT p1.latitude, p1.longitude INTO v_initiator_lat, v_initiator_lng
  FROM profiles p1 WHERE p1.user_id = v_session.initiator_id;
  
  SELECT p2.latitude, p2.longitude INTO v_invitee_lat, v_invitee_lng
  FROM profiles p2 WHERE p2.user_id = v_session.invitee_id;
  
  -- Calculate midpoint (simple average for now)
  v_midpoint_lat := COALESCE((v_initiator_lat + v_invitee_lat) / 2, v_initiator_lat, v_invitee_lat);
  v_midpoint_lng := COALESCE((v_initiator_lng + v_invitee_lng) / 2, v_initiator_lng, v_invitee_lng);
  
  -- Return courts sorted by distance and availability
  RETURN QUERY
  SELECT 
    c.id as court_id,
    c.name as court_name,
    c.location_address as court_address,
    c.hourly_price,
    CASE 
      WHEN c.latitude IS NOT NULL AND c.longitude IS NOT NULL AND v_midpoint_lat IS NOT NULL 
      THEN SQRT(
        POW(69.1 * (c.latitude - v_midpoint_lat), 2) + 
        POW(69.1 * (v_midpoint_lng - c.longitude) * COS(c.latitude / 57.3), 2)
      )
      ELSE 999999
    END as distance_km,
    -- Simple availability score (can be enhanced)
    CASE 
      WHEN EXISTS (
        SELECT 1 FROM bookings b 
        WHERE b.court_id = c.id 
        AND b.start_time <= v_session.proposed_datetime 
        AND b.end_time > v_session.proposed_datetime
        AND b.status = 'confirmed'
      ) THEN 0
      ELSE 100
    END as availability_score
  FROM courts c
  WHERE c.sport_type = v_session.sport
  ORDER BY availability_score DESC, distance_km ASC
  LIMIT p_limit;
END;
$$;

-- Function to process session status updates and trigger notifications
CREATE OR REPLACE FUNCTION handle_session_status_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_initiator_name text;
  v_invitee_name text;
  v_court_name text;
BEGIN
  -- Get participant names
  SELECT p1.first_name || ' ' || p1.last_name INTO v_initiator_name
  FROM profiles p1 WHERE p1.user_id = NEW.initiator_id;
  
  SELECT p2.first_name || ' ' || p2.last_name INTO v_invitee_name
  FROM profiles p2 WHERE p2.user_id = NEW.invitee_id;
  
  -- Get court name if selected
  IF NEW.selected_court_id IS NOT NULL THEN
    SELECT c.name INTO v_court_name
    FROM courts c WHERE c.id = NEW.selected_court_id;
  END IF;
  
  -- Handle different status changes
  CASE NEW.status
    WHEN 'pending_acceptance' THEN
      -- Notify invitee about new session invitation
      INSERT INTO notifications (user_id, actor_id, type, message, related_entity_id)
      VALUES (
        NEW.invitee_id,
        NEW.initiator_id,
        'new_game_request',
        v_initiator_name || ' has invited you to play ' || NEW.sport,
        NEW.id
      );
      
    WHEN 'court_selection' THEN
      -- Notify initiator that invitee accepted
      INSERT INTO notifications (user_id, actor_id, type, message, related_entity_id)
      VALUES (
        NEW.initiator_id,
        NEW.invitee_id,
        'request_accepted',
        v_invitee_name || ' accepted your game invitation. Choose a court!',
        NEW.id
      );
      
    WHEN 'pending_payment' THEN
      -- Notify both users about payment requirement
      INSERT INTO notifications (user_id, type, message, related_entity_id)
      VALUES 
        (
          NEW.initiator_id,
          'booking_confirmed',
          'Complete payment to secure your court at ' || COALESCE(v_court_name, 'selected venue'),
          NEW.id
        ),
        (
          NEW.invitee_id,
          'booking_confirmed',
          'Complete payment to secure your court at ' || COALESCE(v_court_name, 'selected venue'),
          NEW.id
        );
        
    WHEN 'confirmed' THEN
      -- Notify both users about successful booking
      INSERT INTO notifications (user_id, type, message, related_entity_id)
      VALUES 
        (
          NEW.initiator_id,
          'booking_confirmed',
          'Booking confirmed! Your game is at ' || COALESCE(v_court_name, 'selected venue'),
          NEW.id
        ),
        (
          NEW.invitee_id,
          'booking_confirmed',
          'Booking confirmed! Your game is at ' || COALESCE(v_court_name, 'selected venue'),
          NEW.id
        );
        
    WHEN 'cancelled' THEN
      -- Notify both users about cancellation
      INSERT INTO notifications (user_id, type, message, related_entity_id)
      VALUES 
        (
          NEW.initiator_id,
          'booking_confirmed',
          'Your game session with ' || v_invitee_name || ' has been cancelled',
          NEW.id
        ),
        (
          NEW.invitee_id,
          'booking_confirmed',
          'Your game session with ' || v_initiator_name || ' has been cancelled',
          NEW.id
        );
  END CASE;
  
  RETURN NEW;
END;
$$;

-- Create trigger for session status changes
DROP TRIGGER IF EXISTS trigger_session_status_change ON game_sessions;
CREATE TRIGGER trigger_session_status_change
  AFTER INSERT OR UPDATE OF status ON game_sessions
  FOR EACH ROW
  EXECUTE FUNCTION handle_session_status_change();

-- Function to automatically cancel expired sessions
CREATE OR REPLACE FUNCTION cancel_expired_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Cancel sessions stuck in pending_payment for more than 15 minutes
  UPDATE game_sessions 
  SET status = 'cancelled', updated_at = now()
  WHERE status = 'pending_payment' 
  AND updated_at < (now() - INTERVAL '15 minutes');
  
  -- Cancel sessions stuck in pending_acceptance for more than 24 hours
  UPDATE game_sessions 
  SET status = 'cancelled', updated_at = now()
  WHERE status = 'pending_acceptance' 
  AND created_at < (now() - INTERVAL '24 hours');
  
  -- Cancel sessions stuck in court_selection for more than 2 hours
  UPDATE game_sessions 
  SET status = 'cancelled', updated_at = now()
  WHERE status = 'court_selection' 
  AND updated_at < (now() - INTERVAL '2 hours');
END;
$$;

-- Function to get user's active sessions
CREATE OR REPLACE FUNCTION get_user_active_sessions(p_user_id uuid DEFAULT auth.uid())
RETURNS TABLE (
  session_id uuid,
  status text,
  sport text,
  proposed_datetime timestamptz,
  other_user_name text,
  other_user_avatar text,
  court_name text,
  total_cost numeric,
  user_role text,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    gs.id as session_id,
    gs.status,
    gs.sport,
    gs.proposed_datetime,
    CASE 
      WHEN gs.initiator_id = p_user_id THEN invitee_profile.first_name || ' ' || invitee_profile.last_name
      ELSE initiator_profile.first_name || ' ' || initiator_profile.last_name
    END as other_user_name,
    CASE 
      WHEN gs.initiator_id = p_user_id THEN invitee_profile.avatar_url
      ELSE initiator_profile.avatar_url
    END as other_user_avatar,
    c.name as court_name,
    gs.total_cost,
    CASE 
      WHEN gs.initiator_id = p_user_id THEN 'initiator'
      ELSE 'invitee'
    END as user_role,
    gs.created_at
  FROM game_sessions gs
  LEFT JOIN profiles initiator_profile ON gs.initiator_id = initiator_profile.user_id
  LEFT JOIN profiles invitee_profile ON gs.invitee_id = invitee_profile.user_id
  LEFT JOIN courts c ON gs.selected_court_id = c.id
  WHERE (gs.initiator_id = p_user_id OR gs.invitee_id = p_user_id)
  AND gs.status NOT IN ('completed', 'cancelled')
  ORDER BY gs.created_at DESC;
END;
$$;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_game_sessions_participants ON game_sessions(initiator_id, invitee_id);
CREATE INDEX IF NOT EXISTS idx_game_sessions_status ON game_sessions(status);
CREATE INDEX IF NOT EXISTS idx_game_sessions_datetime ON game_sessions(proposed_datetime);
CREATE INDEX IF NOT EXISTS idx_session_chat_session ON session_chat_messages(session_id);
CREATE INDEX IF NOT EXISTS idx_session_chat_created ON session_chat_messages(created_at DESC);

-- Add updated_at trigger for game_sessions
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS update_game_sessions_updated_at ON game_sessions;
CREATE TRIGGER update_game_sessions_updated_at
  BEFORE UPDATE ON game_sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();